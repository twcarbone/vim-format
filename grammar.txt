==============================================================================
1. Tokens

CMD_LET             let
CMD_ECHO            echo
CMD_SET             set

GEN_PLUS            +
GEN_MINUS           -
GEN_QUESTION        ?
GEN_EXCLAMATION     !
GEN_NAME            [a-zA-Z_][a-zA-Z0-9_]*

OP_ADD              +
OP_SUB              -
OP_UNARY_PLUS       +
OP_UNARY_MINUS      -
OP_MUL              *
OP_DIV              /
OP_MODULO           %
OP_EQUAL            ==
OP_NEQUAL           !=
OP_GT               >
OP_GTE              >=
OP_LT               <
OP_LTE              <=
OP_MATCH            =~
OP_NMATCH           !~
OP_IS               is
OP_ISNOT            isnot
OP_OR               ||
OP_AND              &&
OP_MATCH_CASE       #
OP_IGNORE_CASE      ?
OP_TERNARY_IF       ?
OP_TERNARY_ELSE     :
OP_FALSEY           ??
OP_LSHIFT           <<
OP_RSHIFT           >>
OP_CAT_OLD          .
OP_CAT_NEW          ..
OP_LOGICAL_NOT      !
OP_BANG             !
OP_OPTION           &

ASSIGN_ADD          +=
ASSIGN_MINUS        -=
ASSIGN_MUL          *=
ASSIGN_DIV          /=
ASSIGN_EQ           =
ASSIGN_MODULO       %=
ASSIGN_CAT_OLD      .=
ASSIGN_CAT_NEW      ..=

L_PAREN             (
R_PAREN             )
L_BRACKET           [
R_BRACKET           ]
COMMA               ,

IF                  if
ELSEIF              elseif
ELSE                else
ENDIF               endif
WHILE               while
ENDWHILE            endwhile
FOR                 for
IN                  in
ENDFOR              endfor
BREAK               break
CONTINUE            continue
FUNCTION            function                        (v9.1.0698) src/userfunc.c:4755
ENDFUNCTION         endfunction                     ``

FN_RANGE            range                           (v9.1.0698) src/structs.h:1931
FN_ABORT            abort                           ``
FN_DICT             dict                            ``
FN_CLOSURE          closure                         ``
FN_ELLIPSES         ...

END                 End of file
TAB                 0x09
NEWLINE             0x0a
SPACE               0x20

OPTION              [a-z]+
IDENTIFIER          [a-zA-Z_][a-zA-Z0-9_]*
STRING              "..." or '...'
INTEGER             42, 0xff, 0b1101, etc.
FLOAT               3.14, 6.022e+23, -1.4E-5, etc.


==============================================================================
2. Grammar

program
        : END
        | stmt_list END

stmt_list
        : NEWLINE* (stmt NEWLINE+)* NEWLINE*

stmt
        : select_stmt
        | iteration_stmt
        | function_stmt
        | BREAK
        | CONTINUE
        | CMD_ECHO expr1
        | CMD_LET IDENTIFIER (ASSIGN_ADD
                              | ASSIGN_MINUS
                              | ASSIGN_MUL
                              | ASSIGN_DIV
                              | ASSIGN_EQ
                              | ASSIGN_MODULO
                              | ASSIGN_CAT_NEW
                              | ASSIGN_CAT_OLD) expr1

select_stmt
        : IF expr1 stmt_list (ELSEIF expr1 stmt_list)* (ELSE stmt_list)? ENDIF

iteration_stmt
        : WHILE expr1 stmt_list ENDWHILE
        : FOR IDENTIFIER IN (IDENTIFIER | STRING | list_expr) stmt_list ENDFOR

function_stmt
        : FUNCTION OP_BANG? IDENTIFIER L_PAREN arg_list? R_PAREN
            FN_RANGE? FN_ABORT? FN_DICT? FN_CLOSURE? stmt_list ENDFUNCTION

arg_list
        : IDENTIFIER (OP_EQUAL expr1)? (COMMA IDENTIFIER (OP_EQUAL expr1)?)*
            (COMMA FN_ELLIPSES)? COMMA?
        | FN_ELLIPSES COMMA?

        - Non-default arguments cannot appear after default arguments

expr1
        : expr2 (OP_FALSEY expr1)?
        | expr2 (OP_TERNARY_IF expr1 OP_TERNARY_ELSE expr1)?

expr2
        : expr3 (OP_OR expr3)*

expr3
        : expr4 (OP_AND expr4)*

expr4
        : expr5 ((OP_EQUAL
                  | OP_NEQUAL
                  | OP_GT
                  | OP_GTE
                  | OP_LT
                  | OP_LTE
                  | OP_MATCH
                  | OP_NMATCH
                  | OP_IS
                  | OP_ISNOT) (OP_MATCH_CASE | OP_IGNORE_CASE)? expr5)?

expr5
        : expr6 (OP_LSHIFT | OP_RSHIFT expr6)*

expr6
        : expr7 ((OP_ADD | OP_SUB | OP_CAT_OLD | OP_CAT_NEW) expr7)*

expr7
        : expr8 ((OP_MUL | OP_DIV | OP_MODULO) expr8)*

expr8
        : expr9
        | TODO (gh-8)

expr9
        : expr10
        | (OP_LOGICAL_NOT | OP_UNARY_MINUS | OP_UNARY_PLUS) expr9

expr10:
        : expr11
        | TODO (gh-9)

expr11
        : INTEGER
        | FLOAT
        | STRING
        | IDENTIFIER
        | L_PAREN expr1 R_PAREN
        | list_expr

list_expr
        : L_BRACKET (expr1 (COMMA expr1)* COMMA?)? R_BRACKET


==============================================================================
3. Reference

:h expression-commands (v9.1.0698)

    :let {var-name} = {expr1}
    :let {var-name}[{idx}] = {expr1}
    :let {var-name}[{idx1}:{idx2}] = {expr1}
    :let {var} += {expr1}
    :let {var} -= {expr1}
    :let {var} *= {expr1}
    :let {var} /= {expr1}
    :let {var} %= {expr1}
    :let {var} .= {expr1}
    :let {var} ..= {expr1}
    :let ${env-name} = {expr1}
    :let ${env-name} .= {expr1}
    :let @{reg-name} = {expr1}
    :let @{reg-name} .= {expr1}
    :let &{option-name} = {expr1}
    :let &{option-name} .= {expr1}
    :let &{option-name} += {expr1}
    :let &{option-name} -= {expr1}
    :let &l:{option-name} = {expr1}
    :let &l:{option-name} .= {expr1}
    :let &l:{option-name} += {expr1}
    :let &l:{option-name} -= {expr1}
    :let &g:{option-name} = {expr1}
    :let &g:{option-name} .= {expr1}
    :let &g:{option-name} += {expr1}
    :let &g:{option-name} -= {expr1}
    :let [{name1}, {name2}, ...] = {expr1}
    :let [{name1}, {name2}, ...] .= {expr1}
    :let [{name1}, {name2}, ...] += {expr1}
    :let [{name1}, {name2}, ...] -= {expr1}
    :let [{name}, ..., ; {lastname}] = {expr1}
    :let [{name}, ..., ; {lastname}] .= {expr1}
    :let [{name}, ..., ; {lastname}] += {expr1}
    :let [{name}, ..., ; {lastname}] -= {expr1}
    :let {var-name} =<< [trim] [eval] {endmarker}
    :let {var-name} ..
    :let
    :unl[et][!] {name} ...
    :unl[et] ${env-name} ...
    :cons[t] {var-name} = {expr1}
    :cons[t] [{name1}, {name2}, ...] = {expr1}
    :cons[t] [{name}, ..., ; {lastname}] = {expr1}
    :cons[t] {var-name} =<< [trim] [eval] {marker}
    :cons[t]
    :cons[t] {var-name}
    :lockv[ar][!] [depth] {name} ...
    :unlo[ckvar][!] [depth] {name} ...
    :if {expr1}
    :en[dif]
    :el[se]
    :elsei[f] {expr1}
    :wh[ile] {expr1}
    :endw[hile]
    :for {var} in {object}
    :endfo[r]
    :for [{var1}, {var2}, ...] in {listlist}
    :endfo[r]
    :con[tinue]
    :brea[k]
    :try
    :endt[ry]
    :cat[ch] /{pattern}/
    :fina[lly]
    :th[row] {expr1}
    :ec[ho] {expr1} ..
    :echon {expr1} ..
    :echoh[l] {name}
    :echom[sg] {expr1} ..
    :[N]echow[indow] {expr1} ..
    :echoe[rr] {expr1} ..
    :echoc[onsole] {expr1} ..
    :eval {expr}
    :exe[cute] {expr1} ..

C grammar (Credit: https://www.quut.com/c/ANSI-C-grammar-y.html)

    stmt
            : labeled_stmt
            | compound_stmt
            | expr_stmt
            | selection_stmt
            | iteration_stmt
            | jump_stmt

    expr_stmt
            : SEMI
            | expr SEMI

    expr
            : assignment_expr
            | expr COMMA assignment_expr

    assignment_expr
            : conditional_expr
            | unary_expr assignment_op assignment_expr

    conditional_expr        (expr1)
            : logical_or_expr
            | ...

    logical_or_expr         (expr2)
            : logical_and_expr
            | logical_or_expr OP_OR logical_and_expr

    unary_expr
            : TODO

    assignment_op
            : ASSIGN_EQ
            | ASSIGN_MUL
            | ASSIGN_DIV
            | etc.
